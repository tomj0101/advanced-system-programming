#include <stdio.h>
#include <stdlib.h> //pid_t
#include <signal.h>

void startPID(void);
void startFork(void);
void zombieProcesses(void);
void signalsTest(void);
void sig_handler(int sig);

int main(){
    startPID();
	startFork();
	zombieProcesses();
	signalsTest();
    return 0;
}
void startPID(void){
	printf("======== %s ========\n",__func__);
	pid_t pid, ppid;
	pid = getpid();
	ppid = getppid();
	printf("My pid = %d and my Parent's pid = %d \n", pid, ppid);

	/* if you run in the same terminal the proccess id changes but the parent don't changes

	My pid = 1515208 and my Parent's pid = 935052 
	My pid = 1515209 and my Parent's pid = 935052 

	$ps 935052
	PID TTY      STAT   TIME COMMAND
 	935052 pts/0    Ss     0:00 /bin/bash

	ps u # -u userlist:Select by effective user ID (EUID) or name.  This selects the processes whose effective user name or ID is in userlist 
	ps aux #lis all process for all user,session
	
	*/

}

/*Staring another process using fork*/
void startFork(void){
	printf("======== %s ========\n",__func__);
    pid_t pid;
	pid = fork();
	if(pid == 0){
		printf("Child: pid = %u. Parent's pid = %u \n", getpid(), getppid());
	}
}

/*A zombie process is a process that has terminated, but whose parent has not read 
the exit value set by the child. when the parent process terminates,
the zombie process will be removed from the Operating system process table.	

a way to prevent is using wait();
*/
//prevent zombie process using wait()
void zombieProcesses(void){
	printf("======== %s ========\n",__func__);
	pid_t pid;
	int status;
	pid = fork();
	if(pid<0){
		printf("Error: fork() returned %u. \n",pid);
		exit(1);
	}else{
		printf("Parent:pid = %u. Chil's pid = %u \n", getpid(), pid);
		sleep(2);

		pid = wait(&status);
		printf("Parent:pid = %u. Chil's pid = %u \n", getpid(), pid);
		if(WIFEXITED(status) !=0){
			printf("exited with status %d \n", WEXITSTATUS(status));
		}else{
			printf("exited abnormally. \n");
		}
	}

	//prevent zombie process with waitpid()
	//exec command and pass the program name "dir"
	execl("/bin/ls","dir","-al",NULL);

}

/*
Can start a mew process and replace the current process with another, signals also know
as software interrupts, signals are messages sent to a running process.

can fin in the header file /usr/include/bits/signum.h
NAME               VALUE        Function
--------------------------------------------------
SIGHUP				1			Terminal hangup
SIGINT				2			Interrupt(Generated by Ctrl+C) from user
SIQUIT				3			Quit (Generated by Ctrl+\) from user.
SIGKILL				9			Kill the process
SIGUSR1			   10			User-defined signal
....
SIGSTOP			   19			Terminal Stop, generated by Ctrl+Z

*/
static int exit_now = 0;

void signalsTest(void){
	//all signals other than SIGSTOP and SIGKILL can have their behavior modified 
	// by tge installation of a signal handler.
	// function signal() and sigaction() in the header file <signal.h>
	printf("======== %s ========\n",__func__);
	struct sigaction sig_struct;
	sig_struct.sa_handler = sig_handler;
	sigemptyset(&sig_struct.sa_mask);
	sig_struct.sa_flags = 0;

	if(sigaction(SIGINT, &sig_struct, NULL) != 0){
		perror("error");
		exit(1);
	}

	puts("Press Control-C to end processing.");
	while(exit_now == 0){
		puts("Processing.");
		sleep(1);
	}

	puts("Saving data to disk.");

}

void sig_handler(int sig){
	printf("Received signal %d. Exiting soon. \n", sig);
	exit_now = 1;
}